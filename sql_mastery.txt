SQL Mastery for a Software Engineer (practical, complete coverage)

You asked for “each and every SQL query”. That’s impossible: SQL is a language, not a finite list of queries.
What you actually need is: every SQL CONCEPT + the standard query PATTERNS you must be able to write from memory.
This file is that: a dense checklist + examples you can copy, run, and adapt.

Assumptions:
- Examples use ANSI-ish SQL. Some features vary by DB (Postgres/MySQL/SQL Server/SQLite/Oracle).
- Replace ? / :param with your parameter syntax (prepared statements).


============================================================
0) Mental model (non-negotiable)
============================================================
- SQL is declarative: you describe the result, optimizer decides the plan.
- Execution order (conceptual): FROM -> JOIN -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY -> LIMIT/OFFSET
  Note: Window functions happen after WHERE/GROUP BY but before ORDER BY/LIMIT in many engines.
- Three-valued logic: TRUE / FALSE / UNKNOWN (NULL comparisons yield UNKNOWN).
- NULL is not “0” or “empty string”. It means “unknown / missing”.


============================================================
1) Data Definition Language (DDL): schemas, tables, types
============================================================

1.1 Create schema / database
CREATE SCHEMA app;

1.2 Create table (core)
CREATE TABLE users (
  id            BIGINT PRIMARY KEY,
  email         VARCHAR(255) NOT NULL UNIQUE,
  display_name  VARCHAR(100) NOT NULL,
  created_at    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

1.3 Common column types (know what they mean)
- Integers: SMALLINT, INT, BIGINT
- Fixed/variable strings: CHAR(n), VARCHAR(n), TEXT
- Numbers: DECIMAL(p,s)/NUMERIC, FLOAT/DOUBLE (avoid floats for money)
- Time: DATE, TIME, TIMESTAMP (timezone handling differs), INTERVAL
- Bool: BOOLEAN
- Binary: BYTEA/BLOB
- Semi-structured: JSON/JSONB (engine-specific)
- UUID (engine-specific)

1.4 Constraints (must know)
- PRIMARY KEY: uniqueness + not null + index (usually)
- UNIQUE: uniqueness (NULL semantics differ by engine)
- NOT NULL
- CHECK: data invariants
- FOREIGN KEY: referential integrity

Example with FK + CHECK:
CREATE TABLE orders (
  id          BIGINT PRIMARY KEY,
  user_id     BIGINT NOT NULL,
  status      VARCHAR(20) NOT NULL,
  total_cents BIGINT NOT NULL,
  created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT fk_orders_user FOREIGN KEY (user_id) REFERENCES users(id),
  CONSTRAINT chk_total_nonneg CHECK (total_cents >= 0),
  CONSTRAINT chk_status CHECK (status IN ('pending','paid','cancelled','refunded'))
);

1.5 Altering tables (migrations)
ALTER TABLE users ADD COLUMN last_login_at TIMESTAMP;
ALTER TABLE users ALTER COLUMN display_name SET NOT NULL;           -- syntax varies
ALTER TABLE users DROP COLUMN last_login_at;                         -- beware data loss
ALTER TABLE orders ADD CONSTRAINT chk_total_nonneg CHECK (total_cents >= 0);
ALTER TABLE orders DROP CONSTRAINT chk_total_nonneg;                 -- name varies
ALTER TABLE orders RENAME TO purchases;                              -- syntax varies

1.6 Drop (dangerous)
DROP TABLE orders;
DROP SCHEMA app;

1.7 Indexes (know why and when)
CREATE INDEX idx_orders_user_created ON orders (user_id, created_at);
CREATE UNIQUE INDEX idx_users_email ON users (email);                -- sometimes implied by UNIQUE

Index basics you must understand:
- B-tree indexes: equality + range + ordering
- Composite index order matters: (a,b) helps a=, a range, a= and b=; not b alone
- Covering index / included columns (engine-specific)
- Write overhead: indexes slow inserts/updates

1.8 Views
CREATE VIEW active_users AS
SELECT id, email, display_name
FROM users
WHERE email IS NOT NULL;

1.9 Materialized views (engine-specific)
-- Postgres: CREATE MATERIALIZED VIEW ...; REFRESH MATERIALIZED VIEW ...;

1.10 Partitions (engine-specific; but concept matters)
- Range partition on date for large fact tables.
- Hash partition for distribution.
- Partition pruning is the goal.


============================================================
2) Data Manipulation Language (DML): insert/update/delete
============================================================

2.1 Insert
INSERT INTO users (id, email, display_name)
VALUES (1, 'a@example.com', 'Alice');

Multi-row insert:
INSERT INTO users (id, email, display_name) VALUES
(2, 'b@example.com', 'Bob'),
(3, 'c@example.com', 'Cara');

Insert from select:
INSERT INTO users (id, email, display_name)
SELECT id, email, name
FROM imported_users
WHERE email IS NOT NULL;

2.2 Update
UPDATE users
SET display_name = 'Alice A.'
WHERE id = 1;

Update with join (syntax varies)
-- Postgres:
UPDATE orders o
SET status = 'cancelled'
FROM users u
WHERE o.user_id = u.id AND u.email LIKE '%@example.com' AND o.status = 'pending';

2.3 Delete
DELETE FROM orders
WHERE status = 'cancelled' AND created_at < CURRENT_DATE - INTERVAL '90 days';

2.4 Upsert (engine-specific)
-- Postgres:
INSERT INTO users (id, email, display_name)
VALUES (1, 'a@example.com', 'Alice')
ON CONFLICT (id) DO UPDATE
SET email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;

-- MySQL:
INSERT INTO users (id, email, display_name)
VALUES (1,'a@example.com','Alice')
ON DUPLICATE KEY UPDATE
email = VALUES(email),
display_name = VALUES(display_name);

2.5 Returning inserted/updated rows (engine-specific)
-- Postgres:
INSERT INTO users (email, display_name)
VALUES ('d@example.com','Dan')
RETURNING id, created_at;


============================================================
3) Core SELECT (the basics you must be flawless at)
============================================================

3.1 Select columns, aliases
SELECT id, email AS user_email
FROM users;

3.2 Where filters (including NULL)
SELECT *
FROM users
WHERE created_at >= DATE '2026-01-01';

NULL rules:
- = NULL is never true
- use IS NULL / IS NOT NULL
SELECT *
FROM users
WHERE last_login_at IS NULL;

3.3 Order + limit
SELECT *
FROM orders
ORDER BY created_at DESC
LIMIT 50 OFFSET 0;

Pagination warning:
- OFFSET gets slow with large offsets
Keyset pagination pattern:
SELECT *
FROM orders
WHERE (created_at, id) < (:cursor_created_at, :cursor_id)
ORDER BY created_at DESC, id DESC
LIMIT 50;

3.4 Distinct
SELECT DISTINCT status
FROM orders;

3.5 Expressions and functions
SELECT id,
       total_cents / 100.0 AS total_dollars,
       COALESCE(status, 'unknown') AS status_safe
FROM orders;

3.6 Case (if/else)
SELECT id,
       CASE
         WHEN status = 'paid' THEN 1
         WHEN status = 'pending' THEN 0
         ELSE -1
       END AS status_rank
FROM orders;

3.7 IN, BETWEEN, LIKE
SELECT * FROM orders WHERE status IN ('paid','refunded');
SELECT * FROM orders WHERE created_at BETWEEN :start AND :end;
SELECT * FROM users  WHERE email LIKE '%@gmail.com';

3.8 EXISTS (often better than IN with subquery)
SELECT u.*
FROM users u
WHERE EXISTS (
  SELECT 1
  FROM orders o
  WHERE o.user_id = u.id AND o.status = 'paid'
);


============================================================
4) Joins (you must know ALL of these and when they bite you)
============================================================

4.1 INNER JOIN
SELECT o.id, u.email, o.total_cents
FROM orders o
JOIN users u ON u.id = o.user_id;

4.2 LEFT JOIN (keeps left table rows)
SELECT u.id, u.email, o.id AS order_id
FROM users u
LEFT JOIN orders o ON o.user_id = u.id;

Common bug: putting joined-table predicates in WHERE turns it into INNER JOIN.
Wrong (filters out users without orders):
SELECT u.*
FROM users u
LEFT JOIN orders o ON o.user_id = u.id
WHERE o.status = 'paid';

Right:
SELECT u.*
FROM users u
LEFT JOIN orders o
  ON o.user_id = u.id AND o.status = 'paid';

4.3 RIGHT JOIN (rare; can rewrite as LEFT)
4.4 FULL OUTER JOIN (engine support varies)
4.5 CROSS JOIN (cartesian product)
SELECT u.id, d.day
FROM users u
CROSS JOIN dates d;

4.6 Self join
SELECT a.id AS user_a, b.id AS user_b
FROM users a
JOIN users b ON a.email = b.email AND a.id < b.id;

4.7 Join cardinality and duplicates
- One-to-many join duplicates the “one” side.
- You must decide: do you want duplicates, grouping, or distinct?


============================================================
5) Aggregation: GROUP BY, HAVING
============================================================

5.1 Basic aggregates
SELECT status,
       COUNT(*) AS n,
       SUM(total_cents) AS total_cents_sum,
       AVG(total_cents) AS avg_cents,
       MIN(created_at) AS first_order,
       MAX(created_at) AS last_order
FROM orders
GROUP BY status;

5.2 HAVING filters groups (after grouping)
SELECT user_id, COUNT(*) AS n_paid
FROM orders
WHERE status = 'paid'
GROUP BY user_id
HAVING COUNT(*) >= 5;

5.3 Distinct counts
SELECT COUNT(DISTINCT user_id) AS buyers
FROM orders
WHERE status = 'paid';

5.4 Grouping pitfalls
- Selecting non-aggregated columns not in GROUP BY is invalid (or nondeterministic in permissive engines).
- NULLs in group keys form their own group.


============================================================
6) Window functions (must master; separates juniors from seniors)
============================================================
Window functions compute per-row results with access to other rows in the partition.

6.1 Row number, rank
SELECT o.*,
       ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at) AS rn,
       RANK()       OVER (PARTITION BY user_id ORDER BY total_cents DESC) AS rnk,
       DENSE_RANK() OVER (PARTITION BY user_id ORDER BY total_cents DESC) AS drnk
FROM orders o;

6.2 Running totals
SELECT o.*,
       SUM(total_cents) OVER (
         PARTITION BY user_id
         ORDER BY created_at
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       ) AS running_spend
FROM orders o;

6.3 LAG/LEAD (differences over time)
SELECT o.*,
       LAG(total_cents)  OVER (PARTITION BY user_id ORDER BY created_at) AS prev_total,
       total_cents - LAG(total_cents) OVER (PARTITION BY user_id ORDER BY created_at) AS delta
FROM orders o;

6.4 “Top N per group” pattern
WITH ranked AS (
  SELECT o.*,
         ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) AS rn
  FROM orders o
)
SELECT *
FROM ranked
WHERE rn <= 3
ORDER BY user_id, created_at DESC;

6.5 Percentiles (engine-specific; example Postgres)
-- PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY total_cents)

Window pitfalls:
- Window functions happen after WHERE, so filter first then window, or window then filter using a subquery/CTE.


============================================================
7) Subqueries, CTEs, derived tables
============================================================

7.1 Scalar subquery
SELECT u.id,
       (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) AS order_count
FROM users u;

7.2 IN subquery
SELECT *
FROM users
WHERE id IN (SELECT user_id FROM orders WHERE status = 'paid');

7.3 Correlated subquery
SELECT o.*
FROM orders o
WHERE o.total_cents > (
  SELECT AVG(o2.total_cents)
  FROM orders o2
  WHERE o2.user_id = o.user_id
);

7.4 CTE (WITH)
WITH paid_orders AS (
  SELECT *
  FROM orders
  WHERE status = 'paid'
)
SELECT user_id, SUM(total_cents) AS spend
FROM paid_orders
GROUP BY user_id;

7.5 Recursive CTE (trees/graphs)
WITH RECURSIVE org AS (
  SELECT id, manager_id, 0 AS depth
  FROM employees
  WHERE id = :root_id
  UNION ALL
  SELECT e.id, e.manager_id, o.depth + 1
  FROM employees e
  JOIN org o ON e.manager_id = o.id
)
SELECT *
FROM org;

CTE performance note:
- Some DBs materialize CTEs; some inline. Know your engine.


============================================================
8) Set operations
============================================================
UNION removes duplicates, UNION ALL keeps them.
INTERSECT, EXCEPT/MINUS vary by engine.

SELECT email FROM users_a
UNION
SELECT email FROM users_b;

SELECT email FROM users_a
UNION ALL
SELECT email FROM users_b;

-- A not in B:
SELECT email FROM users_a
EXCEPT
SELECT email FROM users_b;


============================================================
9) Transactions, locking, isolation (highly important in real systems)
============================================================

9.1 Transaction basics
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = :from_id;
UPDATE accounts SET balance = balance + 100 WHERE id = :to_id;
COMMIT;

If anything fails: ROLLBACK.

9.2 Isolation levels (know the anomalies)
- READ UNCOMMITTED: dirty reads (rarely used)
- READ COMMITTED: non-repeatable reads possible
- REPEATABLE READ: prevents non-repeatable reads; phantom behavior varies by engine
- SERIALIZABLE: strongest, can abort due to serialization failures

9.3 Locks and “select for update”
-- Postgres/MySQL (InnoDB) style:
BEGIN;
SELECT * FROM accounts WHERE id = :id FOR UPDATE;
UPDATE accounts SET balance = balance + 100 WHERE id = :id;
COMMIT;

9.4 Deadlocks
- Two transactions lock resources in opposite order.
- Fix: consistent lock ordering, smaller transactions, retries for deadlock errors.

9.5 Idempotency and retries
- When you retry on serialization failure or deadlock, your transaction code must be safe to run twice.


============================================================
10) Query performance and correctness
============================================================

10.1 Use EXPLAIN
- Learn to read: sequential scan vs index scan, join types (hash/merge/nested loop), estimated vs actual rows.

10.2 Sargability (index-friendly predicates)
Bad (function on column blocks index use):
WHERE DATE(created_at) = DATE '2026-01-01'

Good:
WHERE created_at >= TIMESTAMP '2026-01-01 00:00:00'
  AND created_at <  TIMESTAMP '2026-01-02 00:00:00'

10.3 Avoid SELECT *
- Pull only what you need. Reduces IO and improves cache hit rates.

10.4 Understand join explosion
- Joining large tables without selective predicates can explode row counts.

10.5 Use proper indexes
Patterns:
- Lookup by FK: index child(fk)
- Time range queries: index(created_at) or (user_id, created_at)
- Sorting + filtering: composite index matches WHERE + ORDER BY

10.6 Anti-patterns (know them)
- N+1 queries from ORM usage
- OFFSET pagination at scale
- Unbounded LIKE '%term%' without full-text index
- Missing constraints leading to bad data and complicated queries

10.7 Statistics and vacuum/optimize (engine-specific)
- The optimizer needs up-to-date stats; maintenance matters.


============================================================
11) Security (must know)
============================================================

11.1 SQL Injection (never do string concatenation)
Bad:
"SELECT * FROM users WHERE email = '" + userInput + "'"

Good:
Prepared statements with parameters:
SELECT * FROM users WHERE email = ?;

11.2 Least privilege
- App user should not be superuser.
- Separate roles for migrations vs runtime.
- Grant only what’s needed:
GRANT SELECT, INSERT, UPDATE ON users TO app_user;

11.3 Row-level security (engine-specific, Postgres example concept)
- Enforce tenant isolation at DB level if needed.

11.4 Sensitive data
- Hash passwords (never store plaintext), encrypt secrets, consider column-level encryption.


============================================================
12) Data modeling (you need this to write sane SQL)
============================================================

12.1 Normalization basics
- 1NF: atomic columns (no repeating groups)
- 2NF/3NF: avoid partial/transitive dependencies
Goal: reduce redundancy and anomalies.

12.2 Denormalization (when performance demands)
- Precomputed aggregates, materialized views, summary tables.
- Must manage consistency and updates.

12.3 Keys
- Natural key vs surrogate key.
- Composite keys are fine if they reflect reality.

12.4 Constraints are your friend
- They reduce bugs and simplify queries.


============================================================
13) Practical “must be able to write” query patterns (memorize)
============================================================

A) “Get last N records”
SELECT *
FROM orders
WHERE user_id = :user_id
ORDER BY created_at DESC
LIMIT :n;

B) “Get unique list with counts”
SELECT status, COUNT(*) AS n
FROM orders
GROUP BY status
ORDER BY n DESC;

C) “Top spender per month” (window + date truncation; engine-specific date funcs)
WITH monthly AS (
  SELECT user_id,
         DATE_TRUNC('month', created_at) AS month,
         SUM(total_cents) AS spend
  FROM orders
  WHERE status = 'paid'
  GROUP BY user_id, DATE_TRUNC('month', created_at)
),
ranked AS (
  SELECT *,
         ROW_NUMBER() OVER (PARTITION BY month ORDER BY spend DESC) AS rn
  FROM monthly
)
SELECT month, user_id, spend
FROM ranked
WHERE rn = 1
ORDER BY month;

D) “Find rows missing in another table”
SELECT u.*
FROM users u
LEFT JOIN orders o ON o.user_id = u.id AND o.status = 'paid'
WHERE o.user_id IS NULL;

E) “Deduplicate, keep newest”
WITH ranked AS (
  SELECT t.*,
         ROW_NUMBER() OVER (PARTITION BY email ORDER BY created_at DESC) AS rn
  FROM users t
)
DELETE FROM users
WHERE id IN (SELECT id FROM ranked WHERE rn > 1);

F) “Upsert”
-- see section 2.4

G) “Pagination keyset”
-- see section 3.3

H) “Soft delete pattern”
UPDATE users SET deleted_at = CURRENT_TIMESTAMP WHERE id = :id;
SELECT * FROM users WHERE deleted_at IS NULL;

I) “Audit trail insert”
INSERT INTO audit_log (entity_type, entity_id, action, actor_id, created_at, payload)
VALUES ('order', :order_id, 'status_changed', :actor_id, CURRENT_TIMESTAMP, :json_payload);

J) “Find duplicates”
SELECT email, COUNT(*) AS n
FROM users
GROUP BY email
HAVING COUNT(*) > 1;

K) “Median/percentile” (engine-specific)
-- Postgres example:
-- SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY total_cents) FROM orders;

L) “Pivot” (engine-specific; concept matters)
- Conditional aggregation is portable:
SELECT user_id,
       SUM(CASE WHEN status='paid' THEN 1 ELSE 0 END) AS paid_n,
       SUM(CASE WHEN status='refunded' THEN 1 ELSE 0 END) AS refunded_n
FROM orders
GROUP BY user_id;


============================================================
14) Database-specific essentials (you should know differences)
============================================================
PostgreSQL:
- Strong SQL support, CTEs, window funcs, JSONB, GIN indexes, EXPLAIN ANALYZE
MySQL:
- InnoDB behavior, isolation defaults, different upsert syntax, limited full outer join
SQL Server:
- T-SQL syntax, TOP, MERGE, clustered indexes, locking hints
SQLite:
- Lightweight, limited concurrency, dynamic typing quirks
Oracle:
- Different date/time, sequences, analytical functions, optimizer specifics

Rule: learn ANSI first, then learn your engine’s deviations.


============================================================
15) What “mastery” looks like (self-test)
============================================================
You can do these without help:
- Write any join correctly, including correct placement of predicates for LEFT JOIN.
- Explain NULL behavior and fix NULL bugs with COALESCE and proper predicates.
- Build queries using GROUP BY/HAVING without mistakes.
- Use window functions for “top N per group”, running totals, and changes over time.
- Make transactions safe with retries for deadlocks/serialization failures.
- Read EXPLAIN, add the right index, and prove it helped.
- Prevent SQL injection with parameterized queries always.
- Design tables with constraints so the DB enforces invariants.

If you want practice:
- Do 50+ window function problems.
- Do 50+ join/aggregation problems.
- Build 1 schema from scratch and enforce invariants with constraints.

End.
